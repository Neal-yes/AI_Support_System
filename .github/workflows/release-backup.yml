name: Release Backup Artifacts

on:
  workflow_dispatch:
    inputs:
      run_id:
        description: "Optional: backup-restore run_id to release (defaults to latest successful)"
        required: false
        type: string
      tag:
        description: "Optional: tag name for release (defaults to auto-generated)"
        required: false
        type: string
      name:
        description: "Optional: release name (defaults to auto-generated)"
        required: false
        type: string
  workflow_run:
    workflows: ["Backup & Restore Qdrant"]
    types:
      - completed

permissions:
  contents: write
  actions: read

jobs:
  release-backup:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    # Run when: manual, or backup-restore completed successfully on main
    if: >-
      ${{ github.event_name == 'workflow_dispatch' ||
          (github.event_name == 'workflow_run' &&
           github.event.workflow_run.conclusion == 'success' &&
           github.event.workflow_run.head_branch == 'main') }}
    env:
      # When triggered by workflow_run, provide the completed backup-restore run id
      RUN_ID: ${{ github.event.workflow_run.id }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve target backup-restore run
        id: resolve_run
        uses: actions/github-script@v7
        with:
          script: |
            const envRun = process.env.RUN_ID || '';
            const runInput = core.getInput('run_id');

            // Helper: find workflow by file path
            async function getWorkflowByPath(path) {
              const { data } = await github.rest.actions.listRepoWorkflows({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100,
              });
              const wf = data.workflows.find(w => w.path === path);
              if (!wf) throw new Error(`Workflow not found by path: ${path}`);
              return wf;
            }

            let runId = 0;
            if (envRun && String(envRun).trim().length) {
              runId = parseInt(String(envRun).trim(), 10);
            } else if (runInput && runInput.trim().length) {
              runId = parseInt(runInput.trim(), 10);
            }
            if (!runId) {
              const wf = await getWorkflowByPath('.github/workflows/backup-restore.yml');
              const { data } = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: wf.id,
                status: 'success',
                per_page: 1,
              });
              if (!data.workflow_runs || !data.workflow_runs.length) {
                throw new Error('No successful backup-restore runs found');
              }
              runId = data.workflow_runs[0].id;
            }

            core.setOutput('run_id', String(runId));

      - name: List artifacts for target run
        id: list_artifacts
        uses: actions/github-script@v7
        env:
          TARGET_RUN_ID: ${{ steps.resolve_run.outputs.run_id }}
        with:
          script: |
            const runIdSrc = process.env.TARGET_RUN_ID || core.getInput('run_id');
            const run_id = parseInt(runIdSrc, 10);
            const { data } = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id,
              per_page: 100,
            });
            if (!data.artifacts || !data.artifacts.length) {
              throw new Error(`No artifacts found for run ${run_id}`);
            }
            // Prefer artifact starting with 'backup-restore-' otherwise take the first
            let artifact = data.artifacts.find(a => a.name.startsWith('backup-restore-')) || data.artifacts[0];
            core.setOutput('artifact_id', String(artifact.id));
            core.setOutput('artifact_name', artifact.name);

      - name: Download artifact zip via API
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          run_id="${{ steps.resolve_run.outputs.run_id }}"
          artifact_id="${{ steps.list_artifacts.outputs.artifact_id }}"
          artifact_name="${{ steps.list_artifacts.outputs.artifact_name }}"
          out_dir="release_artifacts/${run_id}"
          mkdir -p "$out_dir"
          echo "Downloading artifact id=$artifact_id name=$artifact_name for run=$run_id"
          curl -fsSL -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            -o "$out_dir/${artifact_name}.zip" \
            "https://api.github.com/repos/${{ github.repository }}/actions/artifacts/${artifact_id}/zip"
          echo "Computing sha256"
          (cd "$out_dir" && shasum -a 256 "${artifact_name}.zip" | tee "${artifact_name}.zip.sha256")
          echo "out_dir=$out_dir" >> "$GITHUB_OUTPUT"

      - name: Extract artifact and generate validation summary
        run: |
          set -euo pipefail
          run_id="${{ steps.resolve_run.outputs.run_id }}"
          artifact_name="${{ steps.list_artifacts.outputs.artifact_name }}"
          out_dir="release_artifacts/${run_id}"
          extract_dir="$out_dir/extract"
          mkdir -p "$extract_dir"
          sudo apt-get update -y
          sudo apt-get install -y jq unzip
          echo "Listing zip entries"
          entries=$(unzip -Z1 "$out_dir/${artifact_name}.zip")
          echo "$entries" | sed -n '1,100p'
          echo "Extracting matched entries deterministically using unzip -p ..."
          emb_entry=$(printf "%s\n" "$entries" | grep -E '^(.*/)?embedding_upsert.json$' | head -n1 || true)
          dump_entry=$(printf "%s\n" "$entries" | grep -E '^(.*/)?qdrant_.*_dump.json$' | head -n1 || true)
          emb_path=""
          dump_path=""
          if [ -n "$emb_entry" ]; then
            unzip -p "$out_dir/${artifact_name}.zip" "$emb_entry" > "$out_dir/embedding_upsert.json" || true
            emb_path="$out_dir/embedding_upsert.json"
          fi
          if [ -n "$dump_entry" ]; then
            unzip -p "$out_dir/${artifact_name}.zip" "$dump_entry" > "$out_dir/qdrant_dump.json" || true
            dump_path="$out_dir/qdrant_dump.json"
          fi
          # Fallback to filesystem search only if needed
          if [ -z "$emb_path" ] || [ -z "$dump_path" ]; then
            echo "Falling back to filesystem search in extract dir..."
            unzip -o "$out_dir/${artifact_name}.zip" -d "$extract_dir" >/dev/null || true
            echo "Extraction tree (top 200 lines):"
            (cd "$extract_dir" && find . -maxdepth 4 -type f -printf '%p\n' | sed -n '1,200p') || true
            [ -z "$emb_path" ] && emb_path=$(find "$extract_dir" -type f -name 'embedding_upsert.json' | head -n1)
            [ -z "$dump_path" ] && dump_path=$(find "$extract_dir" -type f -regex '.*/qdrant_.*_dump.json' | head -n1)
          fi
          if [ -z "$emb_path" ] || [ -z "$dump_path" ]; then
            echo "embedding_upsert.json or qdrant_*_dump.json not found in artifact; writing warning summary and continuing" >&2
            {
              echo "artifact scan warning: required files not found in zip";
              echo "zip: ${artifact_name}.zip";
              echo "emb_path: $emb_path";
              echo "dump_path: $dump_path";
            } > "$out_dir/VALIDATION_SUMMARY.txt"
            exit 0
          fi
          echo "emb_path=$emb_path"
          echo "dump_path=$dump_path"
          exp_total=$(jq -r '.total' "$emb_path")
          exp_src=$(jq -r '.src' "$emb_path")
          exp_coll=$(jq -r '.collection' "$emb_path")
          echo "Derived expects: total=$exp_total src=$exp_src coll=$exp_coll"
          # Run validation script to generate a friendly summary; never fail release even if validation fails
          python3 scripts/validate_backup_artifacts.py \
            --emb "$emb_path" \
            --dump "$dump_path" \
            --expect-total "$exp_total" \
            --expect-src "$exp_src" \
            --expect-collection "$exp_coll" \
            --sample-count 3 \
            > "$out_dir/VALIDATION_SUMMARY.txt" || true

      - name: Generate release notes
        id: notes
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          run_id="${{ steps.resolve_run.outputs.run_id }}"
          artifact_name="${{ steps.list_artifacts.outputs.artifact_name }}"
          out_dir="release_artifacts/${run_id}"
          ts=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          cat > "$out_dir/RELEASE_NOTES.md" << 'EOF'
          # Backup & Restore Artifacts

          本次 Release 来源于最近一次成功的 Backup & Restore 工作流运行，包含以下内容：
          
          - 工件：ZIP 压缩包（内含 embedding_upsert.json 与 qdrant dump）
          - 完整性校验：提供 sha256 摘要文件（.sha256）
          - 运行来源：GitHub Actions backup-restore 工作流

          使用方法：
          1) 下载 ZIP 与其对应的 .sha256 文件
          2) 本地校验：`shasum -a 256 -c <artifact>.zip.sha256`
          3) 解压并按 Playbook 进行校验或恢复演练

          参考文档：docs/backup_restore_playbook.md
          EOF
          # Derive Run Metrics
          metrics_section=""
          emb_json="$out_dir/embedding_upsert.json"
          dump_json="$out_dir/qdrant_dump.json"
          coll=""
          src=""
          total=""
          restored_total=""
          if [ -f "$emb_json" ]; then
            coll=$(jq -r '.collection // empty' "$emb_json" || true)
            src=$(jq -r '.src // empty' "$emb_json" || true)
            total=$(jq -r '.total // empty' "$emb_json" || true)
          fi
          if [ -f "$dump_json" ]; then
            restored_total=$(jq -r 'if type=="object" then (.points // []) | length else length end' "$dump_json" || true)
          fi
          # RTO seconds from workflow run timing
          rto_secs=""
          run_json="$out_dir/run_${run_id}.json"
          curl -fsSL -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/${run_id}" -o "$run_json" || true
          if [ -s "$run_json" ]; then
            started=$(jq -r '.run_started_at // .created_at // empty' "$run_json" || true)
            updated=$(jq -r '.updated_at // .completed_at // empty' "$run_json" || true)
            if [ -n "$started" ] && [ -n "$updated" ]; then
              start_epoch=$(date -d "$started" +%s || true)
              end_epoch=$(date -d "$updated" +%s || true)
              if [ -n "$start_epoch" ] && [ -n "$end_epoch" ]; then
                rto_secs=$(( end_epoch - start_epoch ))
              fi
            fi
          fi
          {
            echo;
            echo "## Run Metrics";
            echo;
            [ -n "$coll" ] && echo "- collection: $coll" || true;
            [ -n "$src" ] && echo "- src: $src" || true;
            [ -n "$total" ] && echo "- seed_total: $total" || true;
            [ -n "$restored_total" ] && echo "- restored_total: $restored_total" || true;
            [ -n "$rto_secs" ] && echo "- RTO_seconds: $rto_secs" || true;
          } >> "$out_dir/RELEASE_NOTES.md"
          if [ -f "$out_dir/VALIDATION_SUMMARY.txt" ]; then
            {
              echo;
              echo "## Artifact Validation (auto-generated)";
              echo;
              echo '```text';
              cat "$out_dir/VALIDATION_SUMMARY.txt";
              echo '```';
            } >> "$out_dir/RELEASE_NOTES.md"
          fi
          echo "notes_path=$out_dir/RELEASE_NOTES.md" >> "$GITHUB_OUTPUT"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ inputs.tag || format('backup-restore-run-{0}', steps.resolve_run.outputs.run_id) }}
          name: ${{ inputs.name || format('Backup Restore Artifacts (run {0})', steps.resolve_run.outputs.run_id) }}
          body_path: ${{ steps.notes.outputs.notes_path }}
          allowUpdates: true
          files: |
            ${{ steps.list_artifacts.outputs.artifact_name && format('release_artifacts/{0}/{1}.zip', steps.resolve_run.outputs.run_id, steps.list_artifacts.outputs.artifact_name) }}
            ${{ steps.list_artifacts.outputs.artifact_name && format('release_artifacts/{0}/{1}.zip.sha256', steps.resolve_run.outputs.run_id, steps.list_artifacts.outputs.artifact_name) }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Print release info
        if: always()
        run: |
          echo "Released artifacts for run: ${{ steps.resolve_run.outputs.run_id }}"
          echo "Tag: ${{ inputs.tag || format('backup-restore-run-{0}', steps.resolve_run.outputs.run_id) }}"
