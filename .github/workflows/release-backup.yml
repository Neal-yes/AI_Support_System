name: Release Backup Artifacts

on:
  workflow_dispatch:
    inputs:
      run_id:
        description: "Optional: backup-restore run_id to release (defaults to latest successful)"
        required: false
        type: string
      tag:
        description: "Optional: tag name for release (defaults to auto-generated)"
        required: false
        type: string
      name:
        description: "Optional: release name (defaults to auto-generated)"
        required: false
        type: string

permissions:
  contents: write
  actions: read

jobs:
  release-backup:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve target backup-restore run
        id: resolve_run
        uses: actions/github-script@v7
        with:
          script: |
            const runInput = core.getInput('run_id');

            // Helper: find workflow by file path
            async function getWorkflowByPath(path) {
              const { data } = await github.rest.actions.listRepoWorkflows({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100,
              });
              const wf = data.workflows.find(w => w.path === path);
              if (!wf) throw new Error(`Workflow not found by path: ${path}`);
              return wf;
            }

            let runId = runInput && runInput.trim().length ? parseInt(runInput.trim(), 10) : 0;
            if (!runId) {
              const wf = await getWorkflowByPath('.github/workflows/backup-restore.yml');
              const { data } = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: wf.id,
                status: 'success',
                per_page: 1,
              });
              if (!data.workflow_runs || !data.workflow_runs.length) {
                throw new Error('No successful backup-restore runs found');
              }
              runId = data.workflow_runs[0].id;
            }

            core.setOutput('run_id', String(runId));

      - name: List artifacts for target run
        id: list_artifacts
        uses: actions/github-script@v7
        env:
          TARGET_RUN_ID: ${{ steps.resolve_run.outputs.run_id }}
        with:
          script: |
            const runIdSrc = process.env.TARGET_RUN_ID || core.getInput('run_id');
            const run_id = parseInt(runIdSrc, 10);
            const { data } = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id,
              per_page: 100,
            });
            if (!data.artifacts || !data.artifacts.length) {
              throw new Error(`No artifacts found for run ${run_id}`);
            }
            // Prefer artifact starting with 'backup-restore-' otherwise take the first
            let artifact = data.artifacts.find(a => a.name.startsWith('backup-restore-')) || data.artifacts[0];
            core.setOutput('artifact_id', String(artifact.id));
            core.setOutput('artifact_name', artifact.name);

      - name: Download artifact zip via API
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          run_id="${{ steps.resolve_run.outputs.run_id }}"
          artifact_id="${{ steps.list_artifacts.outputs.artifact_id }}"
          artifact_name="${{ steps.list_artifacts.outputs.artifact_name }}"
          out_dir="release_artifacts/${run_id}"
          mkdir -p "$out_dir"
          echo "Downloading artifact id=$artifact_id name=$artifact_name for run=$run_id"
          curl -fsSL -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            -o "$out_dir/${artifact_name}.zip" \
            "https://api.github.com/repos/${{ github.repository }}/actions/artifacts/${artifact_id}/zip"
          echo "Computing sha256"
          (cd "$out_dir" && shasum -a 256 "${artifact_name}.zip" | tee "${artifact_name}.zip.sha256")
          echo "out_dir=$out_dir" >> "$GITHUB_OUTPUT"

      - name: Extract artifact and generate validation summary
        run: |
          set -euo pipefail
          run_id="${{ steps.resolve_run.outputs.run_id }}"
          artifact_name="${{ steps.list_artifacts.outputs.artifact_name }}"
          out_dir="release_artifacts/${run_id}"
          extract_dir="$out_dir/extract"
          mkdir -p "$extract_dir"
          sudo apt-get update -y
          sudo apt-get install -y jq unzip
          echo "Listing zip entries"
          unzip -Z1 "$out_dir/${artifact_name}.zip" | sed -n '1,100p'
          echo "Extracting..."
          unzip -o "$out_dir/${artifact_name}.zip" -d "$extract_dir" >/dev/null
          emb_path=$(find "$extract_dir" -type f -path '*/artifacts/metrics/embedding_upsert.json' | head -n1)
          dump_path=$(find "$extract_dir" -type f -regex '.*/artifacts/metrics/qdrant_.*_dump.json' | head -n1)
          if [ -z "$emb_path" ] || [ -z "$dump_path" ]; then
            echo "embedding_upsert.json or qdrant_*_dump.json not found in artifact; writing warning summary and continuing" >&2
            {
              echo "artifact scan warning: required files not found in zip";
              echo "zip: ${artifact_name}.zip";
              echo "emb_path: $emb_path";
              echo "dump_path: $dump_path";
            } > "$out_dir/VALIDATION_SUMMARY.txt"
            exit 0
          fi
          echo "emb_path=$emb_path"
          echo "dump_path=$dump_path"
          exp_total=$(jq -r '.total' "$emb_path")
          exp_src=$(jq -r '.src' "$emb_path")
          exp_coll=$(jq -r '.collection' "$emb_path")
          echo "Derived expects: total=$exp_total src=$exp_src coll=$exp_coll"
          # Run validation script to generate a friendly summary; never fail release even if validation fails
          python3 scripts/validate_backup_artifacts.py \
            --emb "$emb_path" \
            --dump "$dump_path" \
            --expect-total "$exp_total" \
            --expect-src "$exp_src" \
            --expect-collection "$exp_coll" \
            --sample-count 3 \
            > "$out_dir/VALIDATION_SUMMARY.txt" || true

      - name: Generate release notes
        id: notes
        run: |
          set -euo pipefail
          run_id="${{ steps.resolve_run.outputs.run_id }}"
          artifact_name="${{ steps.list_artifacts.outputs.artifact_name }}"
          out_dir="release_artifacts/${run_id}"
          ts=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          cat > "$out_dir/RELEASE_NOTES.md" << 'EOF'
          # Backup & Restore Artifacts

          本次 Release 来源于最近一次成功的 Backup & Restore 工作流运行，包含以下内容：
          
          - 工件：ZIP 压缩包（内含 embedding_upsert.json 与 qdrant dump）
          - 完整性校验：提供 sha256 摘要文件（.sha256）
          - 运行来源：GitHub Actions backup-restore 工作流

          使用方法：
          1) 下载 ZIP 与其对应的 .sha256 文件
          2) 本地校验：`shasum -a 256 -c <artifact>.zip.sha256`
          3) 解压并按 Playbook 进行校验或恢复演练

          参考文档：docs/backup_restore_playbook.md
          EOF
          if [ -f "$out_dir/VALIDATION_SUMMARY.txt" ]; then
            {
              echo;
              echo "## Artifact Validation (auto-generated)";
              echo;
              echo '```text';
              cat "$out_dir/VALIDATION_SUMMARY.txt";
              echo '```';
            } >> "$out_dir/RELEASE_NOTES.md"
          fi
          echo "notes_path=$out_dir/RELEASE_NOTES.md" >> "$GITHUB_OUTPUT"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ inputs.tag || format('backup-restore-run-{0}', steps.resolve_run.outputs.run_id) }}
          name: ${{ inputs.name || format('Backup Restore Artifacts (run {0})', steps.resolve_run.outputs.run_id) }}
          body_path: ${{ steps.notes.outputs.notes_path }}
          allowUpdates: true
          files: |
            ${{ steps.list_artifacts.outputs.artifact_name && format('release_artifacts/{0}/{1}.zip', steps.resolve_run.outputs.run_id, steps.list_artifacts.outputs.artifact_name) }}
            ${{ steps.list_artifacts.outputs.artifact_name && format('release_artifacts/{0}/{1}.zip.sha256', steps.resolve_run.outputs.run_id, steps.list_artifacts.outputs.artifact_name) }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Print release info
        if: always()
        run: |
          echo "Released artifacts for run: ${{ steps.resolve_run.outputs.run_id }}"
          echo "Tag: ${{ inputs.tag || format('backup-restore-run-{0}', steps.resolve_run.outputs.run_id) }}"
